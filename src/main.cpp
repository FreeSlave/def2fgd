#include <cstring>
#include <cctype>

#include <iostream>
#include <fstream>

#include "defreader.h"
#include "entreader.h"

void writefgd(const char* fileName, const std::vector<Entity>& entities)
{
    std::ofstream stream(fileName);
    if (!stream)
    {
        throw std::runtime_error("Could not open .fgd file for writing");
    }

    stream << "//generated by def2fgd\n\n";
    
    for (size_t i=0; i<entities.size(); ++i)
    {
        const Entity& entity = entities[i];
        if (entity.solid)
        {
            stream << "@SolidClass ";
        }
        else
        {
            stream << "@PointClass size(";
            stream << entity.box[0] << ' ';
            stream << entity.box[1] << ' ';
            stream << entity.box[2] << ", ";
            stream << entity.box[3] << ' ';
            stream << entity.box[4] << ' ';
            stream << entity.box[5] << ')';
            
            if (entity.name != "light")
            {
                stream << " color(" << entity.color[0] << ' ' << entity.color[1] << ' ' << entity.color[2] << ") ";
                
                for (std::vector<Key>::const_iterator it = entity.keys.begin(); it != entity.keys.end(); ++it)
                {
                    if (it->name == "angle" || it->name == "angles")
                    {
                        stream << "flags(Angle) ";
                        break;
                    }
                }
                
                if (!entity.model.empty())
                {
                    stream << "studio(\"" << entity.model << "\") ";
                }
            }
            else
            {
                stream << " iconsprite(\"sprites/light.spr\") flags(Light) ";
            }
        }
        
        stream << "= " << entity.name;
        if (!entity.description.empty())
            stream << " : \"" << entity.description << "\"";
        stream << "\n";
        stream << "[\n";
        for (size_t j=0; j<entity.keys.size(); ++j)
        {
            const Key& key = entity.keys[j];
            stream << "\t" << key.name;
            if (key.name == "target")
            {
                stream << "(target_destination) : Target : : \"" << key.description << "\"";
            }
            else if (key.name == "targetname")
            {
                stream << "(target_source) : Name : : \"" << key.description << "\"";
            }
            else if (key.name == "_color")
            {
                stream << "(color1) : \"RGB color\" : \"1 1 0.5\" : " << "\"" << key.description << "\"";
            }
            else
            {
                std::string name = key.name;
                if (!name.empty())
                    name[0] = toupper(name[0]);
                if (key.type.empty())
                    stream << "(string)";
                else
                    stream << "(" << key.type << ")";
                stream << " : " << name << " : : \"" << key.description << "\"";
            }
            
            stream << "\n";
        }
        
        bool hasspawnflags = false;
        for (size_t j=0; j<Entity::SpawnFlagNum && !hasspawnflags; ++j)
        {
            if (!entity.spawnflags[j].empty())
            {
                hasspawnflags = true;
            }
        }
        
        if (hasspawnflags)
        {
            stream << "\tspawnflags(flags) = \n";
            stream << "\t[\n";
            for (size_t j=0; j<Entity::SpawnFlagNum; ++j)
            {
                std::string flagname = entity.spawnflags[j];
                for (size_t k=0; k<flagname.size(); ++k)
                {
                    flagname[k] = tolower(flagname[k]);
                }
                
                if (!flagname.empty())
                {
                    stream << "\t\t" << (1 << j) << " : \"" << flagname << "\" : 0";
                    if (!entity.flagsdescriptions[j].empty())
                    {
                        stream << " : \"" << entity.flagsdescriptions[j] << "\"";
                    }
                    stream << '\n';
                }
            }
            stream << "\t]\n";
        }
        
        stream << "]\n";
    }
}

int main(int argc, char** argv)
{
    if (argc < 3)
    {
        std::cout << "Usage: " << argv[0] << " input-file output-file" << std::endl;
        return 0;
    }
    
    const char* inputFile = argv[1];
    const char* outputFile = argv[2];
    
    try
    {
        const char* extension = strrchr(argv[1], '.');
        if (extension && strcmp(extension, ".ent") == 0)
        {
            writefgd(outputFile, readEntFile(inputFile));
        }
        else
        {
            writefgd(outputFile, readDefFile(inputFile));
        }
    }
    catch(DefReadError& e)
    {
        std::cerr << e.line() << ":" << e.column() << " " << e.what() << std::endl;
    }
    catch(std::exception& e)
    {
        std::cerr << "Error: " << e.what() << std::endl;
    }
    return 0;
}
