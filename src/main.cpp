//Copyright (c) 2015 Roman Chistokhodov

#include <cstring>
#include <cctype>
#include <cerrno>
#include <cstdlib>
#include <cstdio>

#include <iostream>
#include <fstream>
#include <string>

#include "defreader.h"
#include "entreader.h"

#define DEF2FGD_VERSION "1.0"

void writefgd(std::ostream& stream, const std::vector<Entity>& entities)
{
    stream << "//generated by def2fgd\n\n";
    
    for (size_t i=0; i<entities.size(); ++i)
    {
        Entity entity = entities[i];
        if (entity.solid) {
            stream << "@SolidClass ";
        }
        else {
            stream << "@PointClass size(";
            stream << entity.box[0] << ' ';
            stream << entity.box[1] << ' ';
            stream << entity.box[2] << ", ";
            stream << entity.box[3] << ' ';
            stream << entity.box[4] << ' ';
            stream << entity.box[5] << ')';
            
            if (entity.name == "light" || entity.name == "lightJunior") {
                stream << " iconsprite(\"sprites/light.spr\") flags(Light) ";
                
                if (!entity.hasKey("_color")) {
                    entity.keys.push_back(Key("_color", "weighted RGB value of light color"));
                }
                
            } else {
                stream << " color(" << entity.color[0] << ' ' << entity.color[1] << ' ' << entity.color[2] << ") ";
                
                for (std::vector<Key>::const_iterator it = entity.keys.begin(); it != entity.keys.end(); ++it)
                {
                    if (it->name == "angle" || it->name == "angles") {
                        stream << "flags(Angle) ";
                        break;
                    }
                }
                
                if (!entity.model.empty()) {
                    stream << "studio(\"" << entity.model << "\") ";
                }
            }
        }
        
        stream << "= " << entity.name;
        if (!entity.description.empty()) {
            const size_t tokenLimit = 2047;
            
            if (entity.description.size() > tokenLimit) {
                stream << " : \"" << entity.description.substr(0, tokenLimit) << "\"";
                
                size_t current = tokenLimit;
                while(current <= entity.description.size()) {
                    size_t howMany = entity.description.size() - current < tokenLimit ? entity.description.size() - current : tokenLimit;
                    stream << " + \"" << entity.description.substr(current, tokenLimit) << "\"";
                    current += tokenLimit;
                }
                
            } else {
                stream << " : \"" << entity.description << "\"";
            }
        }
        stream << "\n";
        stream << "[\n";
        for (size_t j=0; j<entity.keys.size(); ++j)
        {
            const Key& key = entity.keys[j];
            stream << "\t" << key.name;
            if (key.name == "target") {
                stream << "(target_destination) : Target : : ";
            }
            else if (key.name == "targetname") {
                stream << "(target_source) : Name : : ";
            }
            else if (key.name == "_color") {
                stream << "(color1) : \"RGB color\" : \"1 1 0.5\" : ";
            } else if (key.name == "model" || key.name == "model2") {
                stream << "(studio) : Model : : ";
            } else {
                std::string name = key.name;
                if (!name.empty())
                    name[0] = toupper(name[0]);
                if (key.type.empty())
                    stream << "(string)";
                else
                    stream << "(" << key.type << ")";
                stream << " : " << name << " : : ";
            }
            
            stream << "\"" << key.description << "\"";
            stream << "\n";
        }
        
        bool hasspawnflags = false;
        for (size_t j=0; j<Entity::SpawnFlagNum && !hasspawnflags; ++j)
        {
            if (!entity.spawnflags[j].empty()) {
                hasspawnflags = true;
            }
        }
        
        if (hasspawnflags)
        {
            stream << "\tspawnflags(flags) = \n";
            stream << "\t[\n";
            for (size_t j=0; j<Entity::SpawnFlagNum; ++j)
            {
                std::string flagname = entity.spawnflags[j];
                for (size_t k=0; k<flagname.size(); ++k)
                {
                    flagname[k] = tolower(flagname[k]);
                }
                
                if (!flagname.empty()) {
                    stream << "\t\t" << (1 << j) << " : \"" << flagname << "\" : 0";
                    if (!entity.flagsdescriptions[j].empty()) {
                        stream << " : \"" << entity.flagsdescriptions[j] << "\"";
                    }
                    stream << '\n';
                }
            }
            stream << "\t]\n";
        }
        
        stream << "]\n";
    }
}

void printHelp(const char* programName)
{
    printf( "Usage: %s [OPTIONS...] [INPUT-FILE] [OUTPUT-FILE]\n"
            "\n"
            "  -format format     specify format of input: def or ent\n"
            "  -help              display this help and exit\n"
            "  -version           output version information and exit\n"
            "  -- [arguments...]  treat arguments as positional arguments\n"
            "\n"
            "With no INPUT-FILE or when INPUT-FILE is -, read standard input.\n"
            "With no OUTPUT-FILE, write to standard output.\n"
    , programName);
}

void printVersion()
{
    printf("def2fgd %s\n", DEF2FGD_VERSION);
}

int main(int argc, char** argv)
{
    const char* format = "";
    const char* inputFileName = 0;
    const char* outputFileName = 0;
    
    std::vector<const char*> positionalArgs;
    const char* programName = argv[0];
    for(int i=1; i<argc; ++i) {
        const char* arg = argv[i];
        if (strcmp(arg, "-format") == 0) {
            if (format[0]) {
                fprintf(stderr, "format option repetition\n");
                return EXIT_FAILURE;
            }
            
            i++;
            if (i < argc) {
                format = argv[i];
            } else {
                fprintf(stderr, "-format option expects argument\n");
                return EXIT_FAILURE;
            }
        } else if (strcmp(arg, "-help") == 0) {
            printHelp(programName);
            return EXIT_SUCCESS;
        } else if (strcmp(arg, "-version") == 0) {
            printVersion();
            return EXIT_SUCCESS;
        } else if (strcmp(arg, "--") == 0) {
            for (; ++i<argc;) {
                positionalArgs.push_back(arg);
            }
        } else {
            positionalArgs.push_back(arg);
        }
    }
    
    if (positionalArgs.size() > 0) {
        inputFileName = positionalArgs[0];
        if (positionalArgs.size() > 1) {
            outputFileName = positionalArgs[1];
        }
    }
    
    if (format[0] == '\0') {
        if (inputFileName && strcmp(inputFileName, "-") != 0) {
            const char* extension = strrchr(inputFileName, '.');
            if (extension && strcmp(extension, ".ent") == 0){
                format = "ent";
            } else if (extension && strcmp(extension, ".def") == 0) {
                format = "def";
            } else {
                fprintf(stderr, "Could not detect input format. Use -format option to explicitly set it.\n");
                return EXIT_FAILURE;
            }
        } else {
            fprintf(stderr, "No input file nor format given.\nUse %s -help\n", argv[0]);
            return EXIT_FAILURE;
        }
    }
    
    std::istream* inStream = &std::cin;
    std::ostream* outStream = &std::cout;
    
    std::ifstream inFile;
    std::ofstream outFile;
    
    if (inputFileName && strcmp(inputFileName, "-") != 0) {
        inFile.open(inputFileName);
        if (!inFile) {
            fprintf(stderr, "Could not open %s for reading: %s\n", inputFileName, strerror(errno));
            return EXIT_FAILURE;
        }
        inStream = &inFile;
    }
    
    try
    {
        std::vector<Entity> entities;
        if (strcmp(format, "def") == 0) {
            entities = readDefFile(*inStream);
        } else if (strcmp(format, "ent") == 0) {
            entities = readEntFile(*inStream);
        } else {
            fprintf(stderr, "Unknown format %s\n", format);
            return EXIT_FAILURE;
        }
        
        if (outputFileName) {
            outFile.open(outputFileName);
            if (!outFile) {
                fprintf(stderr, "Could not open %s for writing: %s\n", outputFileName, strerror(errno));
                return EXIT_FAILURE;
            }
            outStream = &outFile;
        }
        
        writefgd(*outStream, entities);
        outStream->flush();
    }
    catch(DefReadError& e)
    {
        std::cerr << inputFileName << ":" << e.line() << ":" << e.column() << " " << e.what() << std::endl;
        return EXIT_FAILURE;
    }
    catch(std::exception& e)
    {
        std::cerr << "Error: " << e.what() << std::endl;
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;
}
