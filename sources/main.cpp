#include <iostream>
#include <cctype>
#include <fstream>
#include "defreader.h"


void writefgd(const char* fileName, const std::vector<Entity>& entities)
{
    std::ofstream stream(fileName);
    if (!stream.is_open())
    {
        throw std::runtime_error("Could not open file");
    }
    else
    {
        stream << "//generated by def2fgd\n\n";
        
        for (size_t i=0; i<entities.size(); ++i)
        {
            const Entity& entity = entities[i];
            if (entity.solid)
            {
                stream << "@SolidClass";
            }
            else
            {
                stream << "@PointClass size(";
                stream << entity.size[0] << ' ';
                stream << entity.size[1] << ' ';
                stream << entity.size[2] << ", ";
                stream << entity.size[3] << ' ';
                stream << entity.size[4] << ' ';
                stream << entity.size[5] << ')';
                
                if (entity.name != "light")
                {
                    stream << " color(" << entity.color[0] << ' ' << entity.color[1] << ' ' << entity.color[2] << ") ";
                    
                    for (std::vector<Key>::const_iterator it = entity.keys.begin(); it != entity.keys.end(); ++it)
                    {
                        if (it->name == "angle")
                        {
                            stream << "flags(Angle) ";
                            break;
                        }
                    }
                    
                    if (!entity.model.empty())
                    {
                        stream << "studio(\"" << entity.model << "\") ";
                    }
                }
                else
                {
                    stream << " iconsprite(\"sprites/light.spr\") flags(Light) ";
                }
            }
            
            stream << "= " << entity.name;
            if (!entity.description.empty())
                stream << " : \"" << entity.description << "\"";
            stream << "\n";
            stream << "[\n";
            for (size_t j=0; j<entity.keys.size(); ++j)
            {
                const Key& key = entity.keys[j];
                stream << "\t" << key.name;
                if (key.name == "target")
                {
                    stream << "(target_destination)";
                    stream << " : Target : : \"" << key.description << "\"";
                }
                else if (key.name == "targetname")
                {
                    stream << "(target_source)";
                    stream << " : Name : : \"" << key.description << "\"";
                }
                else if (key.name == "_color")
                {
                    stream << "(color1) : \"RGB color\" : \"1 1 0.5\" : " << "\"" << key.description << "\"";
                }
                else
                {
                    std::string name = key.name;
                    if (!name.empty())
                        name[0] = toupper(name[0]);
                    stream << "(string)";
                    stream << " : " << name << " : : \"" << key.description << "\"";
                }
                
                stream << "\n";
            }
            
            bool hasspawnflags = false;
            for (size_t j=0; j<32 && !hasspawnflags; ++j)
            {
                if (!entity.spawnflags[j].empty())
                {
                    hasspawnflags = true;
                }
            }
            
            if (hasspawnflags)
            {
                stream << "\tspawnflags(flags) = \n";
                stream << "\t[\n";
                for (size_t j=0; j<32; ++j)
                {
                    std::string flagname = entity.spawnflags[j];
                    for (size_t k=0; k<flagname.size(); ++k)
                    {
                        flagname[k] = tolower(flagname[k]);
                    }
                    
                    if (!flagname.empty())
                    {
                        stream << "\t\t" << (1 << j) << " : \"" << flagname << "\" : 0";
                        if (!entity.flagsdescriptions[j].empty())
                        {
                            stream << " : \"" << entity.flagsdescriptions[j] << "\"";
                        }
                        stream << '\n';
                    }
                }
                stream << "\t]\n";
            }
            
            stream << "]\n";
        }
    }
}

int main(int argc, char** argv)
{
    if (argc < 3)
    {
        std::cout << "Usage: " << argv[0] << " input-file output-file" << std::endl;
        return 0;
    }
    try
    {
        writefgd(argv[2], readDefFile(argv[1]));
    }
    catch(DefReadError& e)
    {
        std::cerr << e.line() << ":" << e.column() << " " << e.what() << std::endl;
    }
    catch(std::runtime_error& e)
    {
        std::cerr << e.what() << std::endl;
    }
    return 0;
}